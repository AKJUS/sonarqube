/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.db.sca;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
import org.sonar.api.utils.System2;
import org.sonar.db.DbTester;

import static org.assertj.core.api.Assertions.assertThat;

class ScaVulnerabilityIssuesDaoIT {

  @RegisterExtension
  private final DbTester db = DbTester.create(System2.INSTANCE);

  private final ScaVulnerabilityIssuesDao scaVulnerabilityIssuesDao = db.getDbClient().scaVulnerabilityIssuesDao();

  private static final ScaVulnerabilityIssueDto newScaVulnerabilityIssueDto(String suffix) {
    return new ScaVulnerabilityIssueDto("uuid" + suffix, ScaSeverity.INFO, List.of("cwe-" + suffix), new BigDecimal("7.1"), 1L, 2L);
  }

  @Test
  void insert_shouldPersistScaVulnerabilityIssues() {
    ScaVulnerabilityIssueDto issueDto = newScaVulnerabilityIssueDto("1");
    scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);

    List<Map<String, Object>> select = db.select(db.getSession(), "select * from sca_vulnerability_issues");
    assertThat(select).hasSize(1);
    Map<String, Object> stringObjectMap = select.get(0);
    // we can't compare doubles, so it's hackin' time
    var possibleDouble = stringObjectMap.get("cvss_score");
    if (possibleDouble instanceof Double d) {
      stringObjectMap.put("cvss_score", BigDecimal.valueOf(d));
    }
    assertThat(stringObjectMap).containsExactlyInAnyOrderEntriesOf(
      Map.ofEntries(
        Map.entry("uuid", issueDto.uuid()),
        Map.entry("base_severity", issueDto.baseSeverity().name()),
        Map.entry("cwe_ids", "[" + String.join(", ", issueDto.cweIds().stream().map(s -> "\"" + s + "\"").toList()) + "]"),
        Map.entry("cvss_score", issueDto.cvssScore()),
        Map.entry("created_at", issueDto.createdAt()),
        Map.entry("updated_at", issueDto.updatedAt())));
  }

  @Test
  void insert_canSaveNullCvssScore() {
    ScaVulnerabilityIssueDto issueDtoNotNull = newScaVulnerabilityIssueDto("1");
    ScaVulnerabilityIssueDto issueDto = new ScaVulnerabilityIssueDto(issueDtoNotNull.uuid(), ScaSeverity.INFO, issueDtoNotNull.cweIds(),
      null, issueDtoNotNull.createdAt(), issueDtoNotNull.updatedAt());

    scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);

    var loadedOptional = scaVulnerabilityIssuesDao.selectByUuid(db.getSession(), issueDto.uuid());

    assertThat(loadedOptional).contains(issueDto);
    assertThat(loadedOptional.get().cvssScore()).isNull();
  }

  @Test
  void insert_canSaveTenCvssScore() {
    ScaVulnerabilityIssueDto issueDtoBase = newScaVulnerabilityIssueDto("1");
    ScaVulnerabilityIssueDto issueDto = new ScaVulnerabilityIssueDto(issueDtoBase.uuid(), ScaSeverity.INFO,
      issueDtoBase.cweIds(), new BigDecimal("10.0"), issueDtoBase.createdAt(), issueDtoBase.updatedAt());
    assertThat(issueDto.cvssScore().scale()).isEqualTo(1);

    scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);

    // the different db backends are not consistent about actually keeping the scale
    // so we have to fix it to be what we expect
    var loadedOptionalScore = scaVulnerabilityIssuesDao.selectByUuid(db.getSession(), issueDto.uuid())
      .map(ScaVulnerabilityIssueDto::cvssScore)
      .map(score -> score.setScale(1, RoundingMode.HALF_UP));

    assertThat(loadedOptionalScore).contains(issueDto.cvssScore());
  }

  @Test
  void selectByUuid_shouldLoadScaVulnerabilityIssue() {
    ScaVulnerabilityIssueDto issueDto = newScaVulnerabilityIssueDto("1");
    scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);

    var loadedOptional = scaVulnerabilityIssuesDao.selectByUuid(db.getSession(), issueDto.uuid());

    assertThat(loadedOptional).contains(issueDto);
  }

  @Test
  void selectByUuids_shouldLoadScaVulnerabilityIssues() {
    List<ScaVulnerabilityIssueDto> issueDtos = List.of(newScaVulnerabilityIssueDto("1"),
      newScaVulnerabilityIssueDto("2"), newScaVulnerabilityIssueDto("3"));
    for (var issueDto : issueDtos) {
      scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);
    }

    List<String> uuidsToLoad = List.of(issueDtos.get(0).uuid(), issueDtos.get(2).uuid());
    var loaded = scaVulnerabilityIssuesDao.selectByUuids(db.getSession(), uuidsToLoad);

    assertThat(loaded).containsExactlyInAnyOrder(issueDtos.get(0), issueDtos.get(2));
  }

  @Test
  void update_shouldModifyScaVulnerabilityIssue() {
    ScaVulnerabilityIssueDto issueDto = newScaVulnerabilityIssueDto("1");
    scaVulnerabilityIssuesDao.insert(db.getSession(), issueDto);
    ScaVulnerabilityIssueDto issueDtoUpdated = new ScaVulnerabilityIssueDto(issueDto.uuid(),
      ScaSeverity.BLOCKER,
      issueDto.cweIds().stream().map(s -> s + "-updated").toList(),
      issueDto.cvssScore().add(new BigDecimal("1.3")),
      issueDto.createdAt(), 5L);

    assertThat(issueDtoUpdated.baseSeverity()).isNotEqualTo(issueDto.baseSeverity());

    scaVulnerabilityIssuesDao.update(db.getSession(), issueDtoUpdated);

    var loadedOptional = scaVulnerabilityIssuesDao.selectByUuid(db.getSession(), issueDto.uuid());

    assertThat(loadedOptional).contains(issueDtoUpdated);
  }
}
